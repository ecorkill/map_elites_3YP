# map_elites_3YP
This repository contains the code to run a MAP-Elites algorithm with a model of the PAL Robotics TIAGo robot. In addition, there is code to run damage injection simulations using policies generated by the MAP-Elites algorithm.

The MAP-Elites algorithm was modified to work with this application. The original MAP-Elites algorithm can be found at: https://github.com/resibots/pymap_elites. 

Dependencies and Requirements:
•	Python 3.9.1 (may work with other versions of python3)
•	Numpy
•	Mpl_toolkits (install matplotlib)

Defining Simulation Parameters:
•	MAX_EVAL: the total number of evaluations for a simulation
•	NUM_BINS: the number of bins in the behaviour map
•	START_POP: the number of policies in the starting population 
•	BATCH_SZ: the size of each generation
•	ALPHA: constant used in the crossover equation
•	SAMPLE: the size of the sampling period
•	SEED: the random seed used for initial population generation
•	RADIUS: the distance that determines the number of suitable solutions

Code Dependencies:
•	Map_elites.py relies on model.py and fitnessMaps.py
•	Model.py relies on robotClasses.py
•	fitnessMaps.py relies on measures.py and a text file that contains a record of the best policies generated for each bin in the map in the past.

Running Simulations:
To run undamaged robot simulations, run the command:

	$ python3 map_elites.py

Simulation parameters can be changed in the map_elites.py file. During the simulation, samples of the behaviour map will be taken and saved to a text file. This filename can be set in fitnessMaps.py. At the end of a simulation, a text file will be created that contains the final behaviour map generated. The output after the simulation will be visualisations of some of the policies from the behaviour map, the final behaviour map and then 3 plots showing the best fitness, the average fitness, and the coverage over generations.

To change the dimensions of the behaviour map, alter the calculations and normalisation values in determineBin() in map_elites.py. If more or less than 5 dimensions are required, fitnessMaps.py will also have to be altered.


To run damage injection simulations, use the command:
	
	$ python3 assessSolutions.py

This relies on the final maps generated after running the previous command. The damage injected is specified in the function assess(). 

	damageAngle = [1, 1, 1, 1, 1, 1, 1]
   	 angles = [0, 0, 0, 0, 0, 0, 0]

damageAngle specifies the type of damage injected into each angle, where 0 specifies that a joint is at a fixed angle and 1 specifies an angle has a fixed offset. Each entry in the array represents the joint, so the first element is joint 1 and the last element is joint 7. Angles specifies the fixed angle or angle offset of each joint. 

The output from these simulations is the altered behaviour map and the number of suitable solutions in the altered map. The goal point can also be changed in this file to simulate the effect of moving the target point.
